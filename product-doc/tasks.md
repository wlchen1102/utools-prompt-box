# 提示词管理工具实施计划

## 概述

本实施计划基于已确认的需求文档和设计文档，严格按照 uTools 插件开发规范，采用测试驱动开发（TDD）方式，实现一期需求的提示词管理功能。项目采用 Vue 3 + Vite 单页应用架构，直接使用 uTools 原生 API，确保每个步骤都符合 uTools 插件开发标准。

**注意：本计划仅实现一期需求，不包含提示词广场、分享、审核等二期功能。**

## 任务列表

### 1. 项目基础设施搭建 ✅ **已完成**

- [x] 1.1 创建 uTools Vue 插件基础结构 ✅ **已完成 2025-01-22**
  - ✅ 使用 Vue3 + Vite + TypeScript 创建项目
  - ✅ 配置 plugin.json 插件配置文件
  - ✅ 创建 preload.js 预加载脚本文件  
  - ✅ 设置符合 uTools 规范的目录结构
  - ✅ 复制 logo.png 到项目目录
  - ✅ 修复 preload 路径配置问题
  - ✅ 修复 preload.js 文件编码问题（UTF-8）
  - **需求引用**: uTools 插件开发规范

- [x] 1.2 配置 uTools 开发环境 ✅ **已完成 2025-01-22**
  - ✅ 安装和配置 Naive UI 组件库（确保无外部 CDN 依赖）
  - ✅ 集成 Pinia 状态管理，配置直接调用 uTools API
  - ✅ 配置 Vue Router 路由系统（用于页面切换）
  - ✅ 设置 uTools API 类型定义文件和全局声明 (src/types/utools.d.ts)
  - ✅ 配置开发环境和 uTools 窗口集成
  - **需求引用**: 要求5.1 (uTools 本地数据库存储)

- [x] 1.3 建立主题色彩系统 ✅ **已完成 2025-01-22**
  - ✅ 创建 CSS 变量定义文件，设置主题色 #00B25A (src/styles/theme.css)
  - ✅ 配置 Naive UI 主题定制 (src/config/theme.ts)
  - ✅ 实现明显卡片阴影效果的样式类
  - ✅ 创建全局样式文件和辅助类
  - **需求引用**: 设计规范 (主题色彩 #00B25A, 卡片阴影效果)

### 2. 核心数据模型和存储层 ✅ **已完成**

- [x] 2.1 定义 TypeScript 数据类型 ✅ **已完成 2025-01-22**
  - ✅ 创建 types/Prompt.ts - 定义 Prompt 接口和 DTO 类型
  - ✅ 创建 types/Tag.ts - 定义 Tag 接口和 DTO 类型，包含10种颜色配置
  - ✅ 创建 types/AppState.ts - 定义应用配置和状态类型
  - ⚠️ 编写类型验证的单元测试 (待后续进行)
  - **需求引用**: 要求4.8 (提示词字段定义), 要求3.9 (标签颜色分类)

- [x] 2.2 实现 uTools API 封装层 ✅ **已完成并修复 2025-07-31**
  - ✅ 创建 utils/utoolsAPI.ts - 封装 utools.db、utools.copyText 等原生 API
  - ✅ 实现 UtoolsDB 类的数据增删改查方法（直接调用 utools.db）
  - ✅ 实现数据备份和恢复功能（使用 utools.db 导出导入）
  - ✅ 支持开发环境 localStorage 模拟
  - ✅ **删除API修复**: 修正utools.db.remove()使用方式，确保传递完整文档对象而非字符串ID
  - ✅ **数据过滤修复**: 修正allDocs()方法，正确过滤已删除文档和按前缀过滤
  - ⚠️ 编写 uTools API 集成测试 (待后续进行)
  - **需求引用**: 要求5.1-5.4 (数据存储功能)

- [x] 2.3 实现数据验证器 ✅ **已完成 2025-01-22**
  - ✅ 创建 utils/validators.ts - 实现数据验证逻辑
  - ✅ 实现 Prompt 和 Tag 的验证规则
  - ✅ 实现错误处理和用户友好的错误消息
  - ✅ 支持创建、更新、完整性验证
  - ⚠️ 编写验证器的单元测试 (待后续进行)
  - **需求引用**: 要求4.7 (删除前确认), 要求9.5 (错误处理)

### 3. 基础组件开发 ✅ **已完成**

- [x] 3.1 开发应用根组件和布局 ✅ **已完成 2025-01-23**
  - ✅ 创建 App.vue - uTools 插件主入口组件
  - ✅ 创建主布局组件，包含导航和路由视图（集成在 App.vue 中）
  - ✅ 实现导航标签切换（提示词管理、提示词广场）
  - ✅ 实现路由切换逻辑和主题色高亮的导航状态
  - ✅ 更新路由配置，添加 MarketplaceView 路由
  - **需求引用**: 要求1.1-1.5 (用户界面布局)

- [x] 3.2 创建提示词广场占位页面 ✅ **已完成 2025-01-23**
  - ✅ 创建 MarketplaceView.vue 组件（作为路由页面）
  - ✅ 实现"正在开发中"的缺省状态设计
  - ✅ 添加缺省图标和提示文案
  - ✅ 添加功能预告列表和返回导航
  - ✅ 采用渐变背景和卡片式布局设计
  - **需求引用**: 要求1.5 (提示词广场缺省状态)

- [x] 3.3 开发通用 UI 组件 ✅ **已完成 2025-01-23**
  - ✅ 创建 ConfirmDialog.vue - 确认对话框组件
  - ✅ 创建 LoadingSpinner.vue - 加载状态组件  
  - ✅ 创建 EmptyState.vue - 空状态组件
  - ✅ 实现完整的 TypeScript 类型定义
  - ✅ 包含动画效果和响应式设计
  - ⚠️ 编写组件的单元测试 (待后续进行)
  - **需求引用**: 要求9.2 (操作反馈), 要求4.7 (删除确认)

### 4. 标签管理功能实现 ✅ **已完成**

- [x] 4.1 开发标签面板组件 ✅ **已完成 2025-01-23**
  - ✅ 创建 TagPanel.vue - 左侧标签面板组件（20%宽度）
  - ✅ 实现"全部"按钮，默认选中状态
  - ✅ 实现标签列表展示，最多6个字符宽度，超过换行
  - ✅ 实现标签选中状态的视觉反馈（#00B25A 主题色高亮）
  - ✅ 实现标签的悬浮操作按钮（编辑、删除）
  - **需求引用**: 要求2.1-2.2, 要求3.1-3.4 (标签面板布局和筛选)

- [x] 4.2 实现标签 CRUD 操作 ✅ **已完成并优化 2025-07-31**
  - ✅ 创建 TagDialog.vue - 标签编辑对话框组件
  - ✅ 实现标签的新增功能和表单验证
  - ✅ 实现标签的编辑功能，支持名称和颜色修改
  - ✅ 实现标签的删除功能，显示关联提示词数量确认
  - ✅ 处理删除标签时移除提示词关联但保留提示词本身
  - ✅ 集成10种颜色选择和表单验证
  - ✅ **UI优化**: 标签长度20字符，显示8字符+省略号
  - ✅ **交互优化**: 悬浮显示横向三点菜单，点击显示下拉操作
  - ✅ **数据修复**: 编辑时正确初始化原始标签数据
  - ✅ **删除修复**: 修复标签删除ID构造错误，统一ID格式规范，解决新旧标签删除异常
  - ✅ **组件修复**: 修复ConfirmDialog属性不匹配问题，移除重复默认标签创建逻辑
  - **需求引用**: 要求3.5-3.8 (标签增删改)

- [x] 4.3 开发标签服务层 ✅ **已完成 2025-01-23**
  - ✅ 创建 services/TagService.ts - 标签业务逻辑
  - ✅ 实现标签数据的持久化存储（基于 uTools DB）
  - ✅ 实现标签和提示词的关联关系管理
  - ✅ 实现标签搜索、统计、导入导出功能
  - ⚠️ 编写标签服务的单元测试和集成测试 (待后续进行)
  - **需求引用**: 要求3.1-3.9 (标签功能模块)

### 5. 提示词卡片系统开发

- [x] 5.1 开发提示词卡片组件 ✅ **已完成 2025-01-23**
  - ✅ 创建 PromptCard.vue - 提示词卡片组件
  - ✅ 实现卡片的明显阴影效果样式
  - ✅ 展示提示词标题、标签、内容预览等信息
  - ✅ 实现查看、复制、编辑、删除功能按钮
  - ✅ 添加来源链接显示、使用次数统计、收藏标记
  - ✅ 实现高亮状态支持（搜索匹配时）
  - **需求引用**: 要求4.2-4.3 (卡片展示和操作按钮)

- [x] 5.2 实现卡片操作功能 ✅ **已完成 2025-01-23**
  - ✅ 实现查看功能 - 展示完整内容并支持 Markdown 渲染
  - ✅ 实现复制功能 - 一键复制 Markdown 格式内容到剪贴板
  - ✅ 创建 PromptViewDialog.vue - 提示词查看弹窗组件
  - ✅ 支持基础 Markdown 渲染（标题、粗体、斜体、代码、链接等）
  - ✅ 显示标签、来源链接、创建/更新时间等完整信息
  - ✅ 集成复制和编辑操作，支持键盘快捷键（ESC关闭）
  - ⚠️ 实现编辑功能 - 打开编辑弹窗修改提示词信息 (待6.2完成)
  - ⚠️ 实现删除功能 - 删除前确认对话框 (待6.2完成)
  - **需求引用**: 要求4.4-4.7 (卡片功能操作)

- [x] 5.3 开发卡片网格布局 ✅ **已完成 2025-01-23**
  - ✅ 创建 CardGrid.vue - 卡片网格容器组件
  - ✅ 实现响应式网格布局，适配不同窗口大小
  - ✅ 实现加载状态的骨架屏效果
  - ✅ 实现空状态展示和搜索无结果状态
  - ✅ 实现搜索关键词高亮功能
  - ⚠️ 实现卡片的拖拽排序功能（可选，待后续）
  - ⚠️ 编写网格布局的渲染测试 (待后续进行)
  - **需求引用**: 要求4.9 (卡片排序), 要求9.1 (响应式设计)

### 6. 提示词管理核心功能 ✅ **已完成**

- [x] 6.1 开发搜索功能组件 ✅ **已完成 2025-07-30**
  - ✅ 创建 SearchBar.vue - 搜索栏组件
  - ✅ 实现根据名称和内容的模糊搜索
  - ✅ 实现搜索防抖机制（500ms 延迟）
  - ✅ 实现搜索历史记录功能
  - ✅ 实现高级筛选功能（标签、来源、排序）
  - ✅ 实现搜索结果的实时更新
  - **需求引用**: 要求4.1 (搜索功能), 要求10.2 (搜索响应时间)

- [x] 6.2 实现提示词 CRUD 操作 ✅ **已完成并优化 2025-07-30**
  - ✅ 创建 PromptDialog.vue - 提示词编辑弹窗（右侧抽屉式设计）
  - ✅ 实现新增提示词功能，包含名称、内容、标签、来源字段
  - ✅ 实现编辑提示词功能，支持修改所有字段
  - ✅ 实现表单验证和错误提示
  - ✅ **UI优化**: 右侧抽屉弹窗，70%宽度，统一字体大小16px
  - ✅ **交互优化**: 去掉Markdown预览，标签改为占位符，移除"管理标签"按钮
  - ✅ **间距优化**: 减少表单项间距，添加分界线，优化底部按钮区域
  - ✅ **数据修复**: 解决ID前缀过滤问题，修复数据持久化问题
  - **需求引用**: 要求4.6-4.8 (提示词编辑和新增)

- [x] 6.3 开发提示词服务层 ✅ **已完成并修复 2025-07-30**
  - ✅ 创建 services/PromptService.ts - 提示词业务逻辑
  - ✅ 实现提示词的增删改查功能
  - ✅ 实现按标签筛选和搜索功能
  - ✅ **数据修复**: 修复 getAllPrompts 方法中的ID过滤逻辑
  - ✅ **数据修复**: 修复 utoolsAPI.ts 中 allDocs 方法过滤掉 _id 字段的问题
  - ✅ **路由修复**: 在 HomeView.vue 中添加 onActivated 钩子，确保路由切换时重新加载数据
  - ⚠️ 编写提示词服务的单元测试 (待后续进行)
  - **需求引用**: 要求4.1-4.9 (提示词卡片功能)

### 6.4 数据持久化问题修复 ✅ **已完成 2025-07-30**

- [x] 6.4.1 修复数据读取问题 ✅ **已完成**
  - ✅ **问题分析**: 发现 utoolsAPI.ts 中 allDocs 方法过滤掉了 _id 字段，但 PromptService 需要它来过滤和提取ID
  - ✅ **修复方案**: 修改 allDocs 方法，保留 _id 字段，只过滤掉 _rev 字段
  - ✅ **测试验证**: 确认新增提示词后能正确保存和读取

- [x] 6.4.2 修复路由切换数据丢失问题 ✅ **已完成**
  - ✅ **问题分析**: HomeView.vue 只在 onMounted 时加载数据，路由切换时不会重新加载
  - ✅ **修复方案**: 添加 onActivated 钩子，在路由激活时重新加载提示词数据
  - ✅ **测试验证**: 确认从广场切换回主页时数据不会丢失

- [x] 6.4.3 修复ID前缀过滤问题 ✅ **已完成**
  - ✅ **问题分析**: 新创建的提示词ID前缀是 prompt_manager_prompt_，但过滤条件只查找 prompt_ 开头
  - ✅ **修复方案**: 修改过滤条件为 includes('prompt_')，使用正则表达式提取ID
  - ✅ **测试验证**: 确认所有提示词都能正确显示

### 7. 状态管理和数据流

- [ ] 7.1 创建 Pinia 状态存储
  - 创建 stores/promptStore.ts - 提示词状态管理
  - 创建 stores/tagStore.ts - 标签状态管理
  - 创建 stores/appStore.ts - 应用配置状态管理
  - 实现状态的持久化同步
  - **需求引用**: 要求9.4 (记住用户偏好)

- [ ] 7.2 实现数据响应式更新
  - 实现标签选择时的提示词筛选联动
  - 实现搜索关键词的实时筛选
  - 实现新增/编辑/删除操作的状态同步
  - 编写状态管理的集成测试
  - **需求引用**: 要求3.2-3.3 (标签筛选联动)

- [ ] 7.3 优化性能和用户体验
  - 实现虚拟滚动优化大量数据展示
  - 实现操作成功/失败的用户反馈提示
  - 实现加载状态的显示
  - 添加操作防抖和节流优化
  - **需求引用**: 要求9.2 (操作反馈), 要求10.3-10.5 (性能要求)

### 8. 主页面集成和路由

- [x] 8.1 开发提示词管理主页面 ✅ **已完成 2025-01-23**
  - ✅ 重新设计 HomeView.vue - 主页面组件
  - ✅ 集成标签面板和卡片网格的左右分栏布局（20% : 80%）
  - ✅ 实现顶部工具栏（搜索框、添加按钮、提示词计数）
  - ✅ 实现基础的组件间数据传递和事件通信结构
  - ✅ 确保布局的响应式适配
  - ✅ 添加空状态展示和提示词卡片基础结构
  - **需求引用**: 要求2.1-2.5 (提示词管理页面布局)

- [x] 8.2 配置路由系统 ✅ **已完成 2025-01-23**
  - ✅ 配置 Vue Router 路由规则（提示词管理、提示词广场）
  - ✅ 实现页面间的导航逻辑和路由元信息
  - ✅ 集成导航标签与路由状态的联动
  - ✅ 确保路由与 uTools 窗口行为的兼容性
  - ⚠️ 实现路由状态的记忆和恢复 (待后续进行)
  - **需求引用**: 要求1.1-1.3 (导航系统)

- [ ] 8.3 实现组件间通信
  - 建立父子组件的 props 和 emits 通信
  - 实现跨组件的状态共享
  - 处理异步操作的状态同步
  - 编写组件集成测试
  - **需求引用**: 全局状态管理需求

### 9. uTools 平台集成

- [ ] 9.1 完善 uTools 插件配置
  - 完善 plugin.json 的 features 配置，设置关键词触发
  - 配置插件图标和描述信息
  - 设置插件的快捷方式和触发条件
  - 验证插件配置的正确性
  - **需求引用**: uTools 插件规范要求

- [ ] 9.2 优化 uTools 集成体验
  - 实现插件窗口的适配和响应式布局
  - 优化复制操作的用户反馈（使用 utools.showNotification）
  - 实现插件的快捷键支持
  - 处理插件的显示和隐藏逻辑
  - **需求引用**: 要求5.1 (uTools 数据库), 要求4.5 (剪贴板复制)

- [ ] 9.3 构建 uTools 插件包
  - 配置 Vite 构建输出符合 uTools 插件要求
  - 创建 .upx 插件包生成脚本
  - 验证插件包的完整性和可安装性
  - 优化插件包大小和加载性能
  - **需求引用**: 要求7.1 (插件启动时间)

### 10. 测试和质量保证

- [ ] 10.1 编写单元测试
  - 为所有工具函数编写单元测试
  - 为所有服务类编写单元测试
  - 为数据验证器编写测试用例
  - 确保测试覆盖率达到 80% 以上
  - **测试框架**: Vitest + Vue Test Utils

- [ ] 10.2 编写组件测试
  - 为所有 Vue 组件编写渲染测试
  - 测试组件的 props 和 emits 功能
  - 测试用户交互事件的处理
  - 测试组件的响应式行为
  - **测试工具**: @vue/test-utils + jsdom

- [ ] 10.3 编写集成测试
  - 测试组件间的数据流和通信
  - 测试状态管理的完整流程
  - 测试 uTools API 集成功能
  - 测试数据持久化和恢复流程
  - **集成范围**: 完整用户操作流程

### 11. 性能优化和用户体验

- [ ] 11.1 实现性能优化
  - 实现大数据量的虚拟滚动
  - 优化搜索功能的防抖处理
  - 实现组件的懒加载
  - 优化 bundle 大小和加载速度
  - **需求引用**: 要求10.2-10.5 (性能要求)

- [ ] 11.2 完善用户体验
  - 实现操作的加载状态和成功提示
  - 添加键盘快捷键支持
  - 实现错误状态的友好提示
  - 优化移动设备的触摸交互
  - **需求引用**: 要求9.1-9.5 (用户体验优化)

- [ ] 11.3 实现数据管理功能
  - 基于 utools.db 实现数据导出功能
  - 实现数据导入恢复功能（JSON格式）
  - 添加数据完整性验证
  - 利用 uTools 云同步特性自动备份数据
  - **需求引用**: 要求5.2-5.3 (数据备份和云同步)

### 12. 最终集成和发布准备

- [ ] 12.1 完整功能测试
  - 执行完整的用户场景测试
  - 验证所有功能的正确性
  - 测试插件在 uTools 环境中的稳定性
  - 进行跨平台兼容性测试
  - **验证范围**: 所有需求文档中的功能点

- [ ] 12.2 代码质量检查
  - 运行 ESLint 和 Prettier 检查
  - 确保 TypeScript 类型检查无错误
  - 执行完整的测试套件
  - 进行代码 review 和重构
  - **质量标准**: 零 linting 错误，90%+ 测试覆盖率

- [ ] 12.3 构建发布版本
  - 构建优化的生产版本（确保符合 uTools 要求）
  - 生成标准的 uTools 插件包 (.upx)
  - 在 uTools 环境中测试插件包的安装和运行
  - 准备插件的使用说明和开发文档
  - **交付物**: 可在 uTools 中安装使用的插件包

## 开发优先级

### 高优先级（核心功能）
- 任务 1-3：项目基础和基础组件
- 任务 4-6：标签管理和提示词管理核心功能
- 任务 7-8：状态管理和页面集成

### 中优先级（增强功能）
- 任务 9：uTools 平台深度集成
- 任务 10：测试覆盖
- 任务 11：性能优化

### 低优先级（完善功能）
- 任务 12：最终集成和发布准备
- 高级 UI 交互和动画效果
- 扩展功能（如批量操作、高级搜索等）

## 里程碑检查点

1. **M1 - 基础框架完成** ✅ **已达成 2025-01-23**：任务 1-3 完成，基础 UI 框架就绪
   - ✅ 项目基础设施搭建完成
   - ✅ 核心数据模型和存储层完成  
   - ✅ 基础组件开发完成
   - ✅ 应用布局和路由系统完成
2. **M2 - 核心功能完成** ✅ **已达成 2025-07-30**：任务 4-6 完成，基本的增删改查功能可用
   - ✅ 标签管理功能实现完成
   - ✅ 提示词卡片系统开发完成
   - ✅ 提示词管理核心功能完成
   - ✅ 数据持久化问题修复完成
3. **M3 - 主要功能集成**：任务 7-8 完成，完整的用户流程可用
4. **M4 - 生产就绪**：任务 9-12 完成，可发布的稳定版本

每个里程碑都应该包含功能演示和回归测试，确保项目按预期进度推进。


## 重要问题解决记录与经验总结

### 问题记录 #1：标签删除功能异常 🔥 **已解决 2025-07-31**

**问题现象**：
- 新创建的标签删除时报错"标签不存在"
- 旧标签能删除成功，新标签删除失败
- uTools.db.allDocs() 返回数据正常，但无法找到对应文档

**根本原因分析**：
1. **ID格式不一致**：
   - 旧标签业务ID：`1753951003943_2wp9wcihg`（纯时间戳）
   - 新标签业务ID：`tag_1753951821542_ugxfaitgy`（包含tag_前缀）
   - 导致ID构造逻辑错误匹配

2. **数据库存储ID构造错误**：
   - 预期存储ID：`prompt_manager_tags_tag_{时间戳}`
   - 实际存储ID：`prompt_manager_tags_tag_tag_{时间戳}`（双重前缀）

3. **API使用错误**：
   - 对uTools.db.remove()传递字符串ID而非文档对象
   - 未按照官方文档要求先get后remove

**解决方案**：
1. **统一ID格式规范**：
   - 业务ID：纯时间戳格式 `{timestamp}_{random}`
   - 存储ID：完整格式 `prompt_manager_tags_tag_{timestamp}_{random}`

2. **修复ID构造逻辑**（在TagService.ts中）：
   ```typescript
   // 智能识别输入ID格式，正确构造存储ID
   let dbKey: string
   if (id.startsWith('prompt_manager_tags_tag_')) {
     dbKey = id  // 完整ID，直接使用
   } else if (id.startsWith('tag_')) {
     const cleanId = id.replace(/^tag_/, '')
     dbKey = `${TagService.TAG_STORE_KEY}_tag_${cleanId}`  // 移除前缀重构
   } else {
     dbKey = `${TagService.TAG_STORE_KEY}_tag_${id}`  // 纯时间戳，直接构造
   }
   ```

3. **修复删除方法**：
   ```typescript
   // 先获取完整文档，再删除
   const fullDoc = await this.db.get(dbKey)
   if (fullDoc) {
     await this.db.remove(fullDoc)  // 传递文档对象而非字符串
   }
   ```

**经验教训**：
- ✅ **uTools API规范**：严格按照官方文档使用API，remove()需传递文档对象
- ✅ **ID设计一致性**：制定明确的ID格式规范，避免混合使用不同格式
- ✅ **向后兼容性**：修复时要考虑历史数据，智能识别多种ID格式
- ✅ **详细日志记录**：添加ID构造过程的日志，便于问题排查
- ✅ **逐步验证**：先解决数据一致性，再处理API调用方式

**预防措施**：
- 定义统一的数据层抽象，隐藏底层ID构造细节
- 添加数据迁移机制，统一历史数据格式
- 编写ID格式的单元测试，确保构造逻辑正确

---

### 问题记录 #2：默认标签重复创建 🛠️ **已解决 2025-07-31**

**问题现象**：
- 每次页面刷新都创建重复的默认标签（"AI写作"、"编程助手"、"翻译工具"）
- 数据库中累积大量重复标签记录

**根本原因**：
- TagStore中loadTags()方法存在逻辑缺陷
- 当getAllTags()过滤后返回空数组时，误判为"无标签"状态
- 自动触发createDefaultTags()创建默认标签

**解决方案**：
- 完全移除createDefaultTags()函数和相关调用逻辑
- 让用户手动创建所需标签，避免自动化的默认数据

**经验教训**：
- ✅ **避免自动化默认数据**：让用户主动创建数据，避免程序自动补充
- ✅ **数据过滤逻辑审查**：仔细检查数据层过滤逻辑对业务逻辑的影响
- ✅ **清理机制**：提供临时的数据清理功能，解决历史问题

---

### 问题记录 #3：ConfirmDialog组件属性不匹配 🔧 **已解决 2025-07-31**

**问题现象**：
- 删除标签时Vue组件报错：`iconRenderMap[this.type] is not a function`
- 控制台显示Vue渲染错误

**根本原因**：
- HomeView.vue中使用了ConfirmDialog不支持的属性
- 使用了`type="danger"`、`detail`、`confirm-text`等不存在的属性
- 正确属性应为`positive-text`、`negative-text`

**解决方案**：
- 移除不支持的`type`和`detail`属性
- 使用正确的属性名称：`positive-text`、`negative-text`

**经验教训**：
- ✅ **组件接口一致性**：确保使用的属性与组件定义完全匹配
- ✅ **TypeScript类型检查**：利用TypeScript的类型系统预防此类错误
- ✅ **组件文档化**：为自定义组件编写清晰的属性接口文档

---

### 问题记录 #4：uTools.db.remove() API使用错误导致删除失败 💥 **已解决 2025-07-31**

**问题现象**：
- 删除操作显示成功，但数据实际未被删除
- `utools.db.allDocs()` 仍然返回"已删除"的数据
- 用户反复删除同一条数据，提示成功但数据依然存在

**根本原因分析**：
1. **API使用方式错误**：
   ```typescript
   // ❌ 错误方式：直接传递字符串ID
   await this.db.remove(dbKey)
   
   // ✅ 正确方式：先获取文档对象，再删除
   const fullDoc = await this.db.get(dbKey)
   if (fullDoc) {
     await this.db.remove(fullDoc)  // 传递完整文档对象
   }
   ```

2. **对uTools官方文档理解不准确**：
   - 虽然官方文档显示`remove(id: string)`支持字符串ID
   - 但实际测试中，传递完整文档对象更可靠
   - 文档对象包含必要的`_id`和`_rev`字段用于版本控制

3. **CouchDB底层机制**：
   - uTools使用CouchDB作为底层数据库
   - CouchDB删除需要文档的版本信息(`_rev`)进行乐观锁控制
   - 直接传递ID可能无法获取到正确的版本信息

**解决方案**：
1. **修改删除方法实现**：
   ```typescript
   // 在TagService.ts和PromptService.ts中统一修改
   async removeDocument(id: string): Promise<boolean> {
     try {
       // 第一步：获取完整文档（包含_id和_rev）
       const fullDoc = await this.db.get(dbKey)
       if (!fullDoc) {
         console.log('⚠️ 文档不存在:', dbKey)
         return false
       }
       
       // 第二步：传递完整文档对象进行删除
       const result = await this.db.remove(fullDoc)
       console.log('✅ 删除结果:', result)
       
       return result.ok === true
     } catch (error) {
       console.error('❌ 删除失败:', error)
       return false
     }
   }
   ```

2. **在utoolsAPI.ts中修正remove方法**：
   ```typescript
   remove(docOrId: string | object): any {
     if (!window.utools) {
       // 开发环境处理
       return { ok: true }
     }
     
     try {
       // 确保传递的是对象而非字符串
       if (typeof docOrId === 'string') {
         console.warn('⚠️ 建议传递文档对象而非字符串ID')
       }
       
       const result = window.utools.db.remove(docOrId)
       console.log('🗑️ 删除结果:', result)
       return result
     } catch (error) {
       console.error('🔴 删除操作失败:', error)
       return { ok: false, error: true, message: error.message }
     }
   }
   ```

**验证方案**：
- 删除后立即调用`utools.db.allDocs()`检查数据是否真正移除
- 检查返回的文档中不应包含`_deleted: true`的墓碑记录
- 在UI层面确认删除的数据不再显示

**经验教训**：
- ✅ **严格遵循API最佳实践**：即使文档支持多种调用方式，选择最可靠的方式
- ✅ **分步骤操作验证**：对于关键操作（如删除），分步验证每个环节
- ✅ **理解底层数据库机制**：了解CouchDB的版本控制和乐观锁机制
- ✅ **充分的日志记录**：记录删除过程的每个步骤，便于问题排查
- ✅ **用户操作验证**：不仅检查API返回值，还要验证实际的数据状态

**预防措施**：
- 为所有数据库操作建立标准的操作模式（get → operate → verify）
- 在关键操作后添加数据一致性检查
- 建立删除操作的回滚机制，预防意外数据丢失

---

### 问题记录 #5：脏数据导致删除异常 🗑️ **已解决 2025-07-31**

**问题现象**：
- 特定提示词（"测额度"）删除后页面仍显示
- 该提示词的ID显示为异常值：`manager_undefined`
- 正常删除流程对该条数据无效

**根本原因分析**：
1. **异常ID生成**：
   - 正常ID格式：`1753785168179_kne4n8t9t`（时间戳_随机字符）
   - 异常ID格式：`manager_undefined`（包含undefined关键字）
   - 说明在某次创建过程中ID生成逻辑出现异常

2. **数据库存储不一致**：
   - 完整存储ID可能为：`prompt_manager_prompt_manager_undefined`
   - 删除时ID构造无法正确匹配到该文档

3. **历史测试数据污染**：
   - 可能是开发过程中某次异常操作产生的脏数据
   - 该数据结构不符合当前的数据规范

**解决方案**：
1. **创建脏数据检测和清理机制**：
   ```typescript
   async cleanInvalidPrompts(): Promise<{ success: boolean; message: string; deletedCount: number }> {
     // 检测异常ID的条件：
     const isInvalidId = (extractedId: string) => {
       return !extractedId || 
              extractedId === 'undefined' || 
              extractedId === 'null' || 
              extractedId.includes('undefined') ||
              extractedId.includes('manager') ||
              extractedId.length < 10  // 正常ID长度应该比较长
     }
     
     // 遍历所有提示词文档，检测并删除异常数据
     for (const promptDoc of promptDocs) {
       const extractedId = promptDoc._id.replace(/^.*prompt_/, '')
       if (isInvalidId(extractedId)) {
         // 删除脏数据
         await this.db.remove(promptDoc)
       }
     }
   }
   ```

2. **添加临时清理功能**：
   - 在UI中添加"清理脏数据"按钮（使用后注释掉）
   - 提供一键清理所有异常数据的功能

**经验教训**：
- ✅ **数据验证机制**：在数据创建时应验证ID格式的正确性
- ✅ **异常数据处理**：建立检测和清理异常数据的机制
- ✅ **开发阶段数据管理**：开发过程中注意数据清洁，避免脏数据积累
- ✅ **数据格式规范**：严格定义数据ID格式规范，并在代码中强制执行

**预防措施**：
- 在ID生成函数中添加格式验证
- 定期检查数据库中的数据完整性
- 建立数据迁移和清理的标准流程

---

### 问题记录 #6：提示词删除后仍显示在页面上 🔄 **已解决 2025-07-31**

**问题现象**：
- 提示词删除操作后提示"删除成功"，但页面上数据依然存在
- 控制台日志显示删除成功，但刷新后数据仍然存在
- 日志显示：`提示词删除成功: {id: 'prompt_manager_prompt_1753958216666_l7hk1x18s', ...}`

**根本原因分析**：
1. **ID处理不一致**：
   - 现在传入的ID是完整格式：`prompt_manager_prompt_1753958216666_l7hk1x18s`
   - 但`removePrompt`方法内部尝试添加前缀：`prompt_${id}`和`prompt_manager_prompt_${id}`
   - 导致构造出错误的ID：`prompt_prompt_manager_prompt_1753958216666_l7hk1x18s`

2. **删除方法逻辑错误**：
   ```typescript
   // 错误的逻辑：尝试不同的ID格式
   let doc = this.db.get(`prompt_${id}`)
   if (!doc) {
     doc = this.db.get(`prompt_manager_prompt_${id}`)
   }
   ```

3. **同样的问题也存在于`updatePrompt`方法中**：
   ```typescript
   // 错误的逻辑：手动构造ID
   const cleanId = doc._id.replace(/^prompt_manager_/, '')
   const result = this.db.put(cleanId, updatedData)
   ```

**解决方案**：
1. **修复`removePrompt`方法**：
   ```typescript
   async removePrompt(id: string): Promise<PromptOperationResult> {
     try {
       console.log('🗑️ 开始删除提示词，直接使用ID:', id)
       
       // 直接使用完整ID获取文档
       const doc = this.db.get(id)
       
       if (!doc) {
         console.log(`提示词 ${id} 在数据库中已不存在，无需删除。`)
         return {
           success: true,
           message: '提示词已删除'
         }
       }

       console.log('🗑️ 找到文档，准备删除:', { id: doc._id, doc })
       
       // 使用文档对象删除
       const result = this.db.remove(doc)
       console.log('🗑️ 删除操作结果:', result)

       // ...其余代码不变
     }
   }
   ```

2. **修复`updatePrompt`方法**：
   ```typescript
   async updatePrompt(id: string, data: UpdatePromptDTO): Promise<PromptOperationResult> {
     try {
       console.log('🔄 更新提示词，直接使用ID:', { id, data })
       
       // 直接使用完整ID获取文档
       const doc = this.db.get(id)
       
       // ...验证逻辑不变

       // 更新数据
       const updatedData = {
         // ...数据字段不变
       }
       
       console.log('🔄 更新提示词数据:', { id, updatedData })
       
       // 直接使用完整ID进行保存
       const result = this.db.put(id, updatedData)

       // ...其余代码不变
     }
   }
   ```

3. **修复`createPrompt`方法**：
   ```typescript
   // 使用完整ID格式保存
   const fullId = `prompt_manager_prompt_${id}`
   const result = this.db.put(fullId, dataToSave)
   
   // 更新prompt对象的id为完整ID，以便返回给调用者
   prompt.id = fullId
   ```

**验证方案**：
- 创建新提示词，确认能正确保存
- 编辑提示词，确认能正确更新
- 删除提示词，确认能真正从数据库中删除并且页面更新

**经验教训**：
- ✅ **统一ID处理逻辑**：整个应用中使用一致的ID格式和处理方式
- ✅ **简化ID处理**：直接使用完整ID，避免复杂的ID转换逻辑
- ✅ **日志驱动调试**：通过详细日志跟踪数据流和操作结果
- ✅ **全面修复**：发现一处ID处理问题后，检查所有相关方法

**预防措施**：
- 在数据层统一ID处理逻辑，避免在业务层进行ID转换
- 添加单元测试验证ID处理逻辑的正确性
- 在关键操作后添加验证步骤，确保操作真正成功

---

### 开发最佳实践总结

#### 🎯 数据层设计原则
1. **统一ID格式**：制定明确的业务ID和存储ID规范
2. **API封装**：隐藏底层uTools API的复杂性，提供一致的接口
3. **向后兼容**：新版本要能处理旧版本的数据格式
4. **详细日志**：在关键数据操作点添加详细日志

#### 🔍 问题排查策略
1. **从用户行为入手**：分析用户操作路径，定位问题触发点
2. **数据流追踪**：跟踪数据从UI到存储的完整流程
3. **控制台日志分析**：充分利用控制台日志定位问题
4. **分层验证**：分别验证UI层、业务层、数据层的功能

#### ⚡ 高效修复流程
1. **问题复现**：先确保能稳定复现问题
2. **根因分析**：深入分析问题的根本原因，不只是修复表象
3. **方案设计**：设计既解决当前问题又不引入新问题的方案
4. **逐步实施**：分步骤实施修复，每步都验证效果
5. **经验记录**：及时记录问题和解决方案，供将来参考 

---

### 问题记录 #7：刷新后提示词与标签失联（ID 前缀不一致） ✅ **已解决 2025-07-31**

**问题现象**：
- 新建提示词 → 创建新标签 → 保存后正常，但刷新/重进页面，提示词的标签变成 ID 或丢失。
- 进入编辑页时还会出现同名标签被再次创建的现象。

**根因**：
- uTools 底层文档 `_id` 为 `prompt_manager_*` 前缀；业务层在提示词里保存的是“无前缀的业务 ID”。
- 读取时未做统一转换，导致 `prompt.tags` 与 `store.tags` 的 ID 维度不一致，刷新后匹配失败。
- 早期还存在“临时标签”写入路径，进一步放大不一致问题。

**修复方案**：
- 统一 ID 语义：读取层一律将 `_id` 去前缀为业务 ID。
  - `TagService.getAllTags()`：`id = String(_id).replace(/^prompt_manager_/, '')`
  - `PromptService.getAllPrompts()/getPromptById()`：同样去前缀。
- 编辑页逻辑简化为“单一通路”：
  - 点击“＋ 创建标签”→ 先查库（名称忽略大小写）→ 存在则直接选中 ID；不存在则创建并选中“真实 ID”。
  - `formData.tags` 全程仅存“真实标签 ID”，不再写入临时值。
  - 打开编辑页强制 `loadTags(true)`；若发现选中 ID 在标签库不存在则从选中移除，避免显示 ID。
- 下拉选项去重：按“名称忽略大小写”去重，避免同名重复显示。

**验证**：
- 新建提示词 → 创建新标签 → 保存 → 刷新：列表和编辑页均稳定显示标签名称。
- 删除标签后再进该提示词：标签不显示 ID，不会被重新创建。

**经验教训**：
- 统一“业务 ID”与“存储 ID”的转换边界，只在数据层完成；UI/业务层只处理业务 ID。
- 去掉临时值路径，避免多源写入造成一致性问题。

**后续行动**：
- 为 ID 转换与查重逻辑补充单元测试；
- 在导入/迁移场景对历史数据执行一次性“去前缀”与同名合并清洗脚本。

---

### 问题记录 #8：试验性“新标签”导致标签库被污染（应先临时选择，提交时再创建） ✅ **已解决 2025-07-31**

**问题现象**：
- 用户在新增提示词弹窗中尝试输入多个“新标签”，即便未点击“创建提示词”，标签库也会留下无用标签。

**需求澄清**：
- 在“新增提示词”浮窗中，点击“＋ 创建标签 ‘xxx’”只应作为临时选择的视觉反馈；只有当用户点击“创建提示词”提交时，才真正落库。

**修复方案**：
- 取消“即时落库”路径，采用“会话内临时标签 + 提交时统一落库”。
  - 选择阶段：
    - 已有标签：直接选中真实 ID；
    - 新标签：加入临时占位 `__temp__:name`，不落库；
  - 提交阶段：
    - 将选择集合转换为真实 ID：对临时项先查库（名称忽略大小写），存在则复用；不存在才创建并返回 ID；
    - 最终仅保存真实 ID 数组到提示词。
- 渲染：
  - 已有标签使用仓库名称渲染；
  - 临时标签显示其名称，不显示 ID。

**效果**：
- 试错不会污染标签库；
- 点击“创建提示词”后才会真正创建标签；
- 刷新/重进后只存在真实 ID，页面与编辑页显示稳定。

**经验教训**：
- 将“交互反馈”与“数据落库”分离，先临时状态，后提交转换；
- 单一通路：创建标签只发生在“提交时的统一收敛”，业务更可控。