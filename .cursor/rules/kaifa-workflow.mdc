---
alwaysApply: false
---
# 需求收集生成

工作流阶段：需求收集

首先，根据功能构想以 EARS 规范（Easy Approach to Requirements Syntax）生成一套初始需求，然后与用户迭代完善，直到它们完整且准确。

在此阶段，不要专注于代码探索。相反，只需专注于编写需求，这些需求稍后将被转化为
设计。

**约束：**

- 模型必须创建一个 `.cursor\rules{feature_name}/requirements.md` 文件，如果它尚不存在。
- 模型必须根据用户的粗略想法生成需求文档的初始版本，而不是先提出一连串问题。
- 模型必须使用以下格式来格式化初始的 requirements.md 文档：
  - 一个清晰的引言部分，总结该功能。
  - 一个分层的编号需求列表，其中每一项包含：
    - 一个用户故事，格式为“作为一名 [角色]，我想要 [功能]，以便 [收益]”。
    - 一个 EARS 格式（Easy Approach to Requirements Syntax，简易需求语法方法）的验收标准编号列表。
  - 示例格式：
[此处包含示例格式]
- 模型应该在初始需求中考虑边界情况、用户体验、技术约束和成功标准。
- 更新需求文档后，模型必须使用 'userInput' 工具询问用户：“需求看起来可以吗？如果可以，我们就可以进入设计阶段了。”。
- 'userInput' 工具必须使用确切的字符串 'spec-requirements-review' 作为原因。
- 如果用户请求更改或未明确批准，模型必须对需求文档进行修改。
- 在每次编辑需求文档的迭代之后，模型都必须请求明确的批准。
- 在收到明确批准（例如“可以”、“已批准”、“看起来不错”等）之前，模型绝不能进入设计文档阶段。
- 模型必须持续进行反馈-修订循环，直到收到明确批准为止。
- 模型应该建议需求中可能需要澄清或扩展的特定领域。
- 模型可以针对需要澄清的需求的特定方面提出有针对性的问题。
- 当用户对某个特定方面不确定时，模型可以建议选项。
- 在用户接受需求后，模型必须进入设计阶段。


# 设计文档创建生成

工作流阶段：设计文档创建

在用户批准需求后，你应该根据功能需求制定一份全面的设计文档，并在设计过程中进行必要的研究。
设计文档应基于需求文档，因此请确保它首先存在。

**约束：**

- 模型必须创建一个 `.cursor\rules/{feature_name}/design.md` 文件，如果它尚不存在。
- 模型必须根据功能需求识别需要研究的领域。
- 模型必须进行研究并在对话线程中建立上下文。
- 模型不应该创建独立的研究文件，而是将研究用作设计和实施计划的上下文。
- 模型必须总结将为功能设计提供信息的关键发现。
- 模型应该在对话中引用来源并包含相关链接。
- 模型必须在 `.cursor\rules/{feature_name}/design.md` 创建一份详细的设计文档。
- 模型必须将研究发现直接融入设计过程。
- 模型必须在设计文档中包含以下部分：
  - 概述 (Overview)
  - 架构 (Architecture)
  - 组件与接口 (Components and Interfaces)
  - 数据模型 (Data Models)
  - 错误处理 (Error Handling)
  - 测试策略 (Testing Strategy)
- 模型应该在适当时包含图表或视觉表示（如果适用，请使用 Mermaid 绘制图表）。
- 模型必须确保设计解决了在澄清过程中确定的所有功能需求。
- 模型应该突出设计决策及其理由。
- 模型可以在设计过程中就具体的技术决策征求用户意见。
- 更新设计文档后，模型必须使用 'userInput' 工具询问用户：“设计看起来可以吗？如果可以，我们就可以进入实施计划阶段了。”。
- 'userInput' 工具必须使用确切的字符串 'spec-design-review' 作为原因。
- 如果用户请求更改或未明确批准，模型必须对设计文档进行修改。
- 在每次编辑设计文档的迭代之后，模型都必须请求明确的批准。
- 在收到明确批准（例如“可以”、“已批准”、“看起来不错”等）之前，模型绝不能进入实施计划阶段。
- 模型必须持续进行反馈-修订循环，直到收到明确批准为止。
- 在继续之前，模型必须将所有用户反馈融入设计文档。
- 如果在设计过程中发现差距，模型必须提议返回功能需求澄清阶段。

## UI设计规范
* **优雅清新**: 追求美学与功能的完美平衡，设计风格现代、简洁、注重用户体验。
* **多样探索**: 两个方案应在视觉上形成有效对比，探索方向包括但不限于：
    * **色彩主题**: 在浅色背景下，使用不同的品牌色或强调色组合。
    * **布局结构**: 尝试不同的信息层级和元素排列方式。
    * **组件样式**: 使用不同样式的卡片、按钮、图标和表单。
    * **视觉风格**: 例如“极简留白”对比“丰富插画”。
* **细节制胜**: 注重留白、圆角、阴影和字体排版，创造精致的视觉感受。

## 技术规格标准
1.  **页面框架**: HTML5 + TailwindCSS 3.0+ (通过CDN引入)。
4.  **图标库**: 使用 Font Awesome 或 Material Icons (通过CDN引入)，禁止使用emoji。
5.  **图片素材**: 使用稳定可靠的图片服务，按以下优先级选择：
    **首选方案**: Picsum Photos占位图服务 - `https://picsum.photos/宽度/高度?random=数字`
    - 示例：`https://picsum.photos/200/300?random=1` (200x300尺寸的随机图片)
    - 头像专用：`https://picsum.photos/64/64?random=1` (正方形头像)
    - 优点：专业稳定、无API限制、加载快速
    
    **备选方案**: 已验证的稳定CDN图片链接
    - 避免使用复杂参数(如&face、&fit=crop等)
    - 优先选择大型CDN服务的图片
    
    **兜底方案**: Placeholder.co自定义占位图 - `https://placehold.co/宽度x高度?text=文字&radius=圆角`
    - 示例：`https://placehold.co/64x64?text=Avatar&radius=32` (圆形头像占位图)


# 实施计划生成

工作流阶段：实施计划

在用户批准设计后，根据需求和设计创建一个可操作的实施计划，其中包含一个编码任务清单。
任务文档应基于设计文档，因此请确保它首先存在。

**约束：**

- 模型必须创建一个 `.cursor\rules/{feature_name}/tasks.md` 文件，如果它尚不存在。
- 如果用户表示需要对设计进行任何更改，模型必须返回到设计步骤。
- 如果用户表示我们需要额外的需求，模型必须返回到需求步骤。
- 模型必须在 `.cursor\rules/{feature_name}/tasks.md` 创建一个实施计划。
- 模型在创建实施计划时必须使用以下具体指令：将功能设计转化为一系列用于代码生成 LLM 的提示，该 LLM 将以测试驱动的方式实现每个步骤。优先考虑最佳实践、增量进度和早期测试，确保在任何阶段都没有复杂性的大幅跳跃。确保每个提示都建立在先前提示的基础上，并最终将所有部分连接起来。不应该有未集成到前一步骤中的悬空或孤立代码。只专注于涉及编写、修改或测试代码的任务。
- 模型必须将实施计划格式化为一个最多两级层次结构的编号复选框列表：
- 顶级项目（如史诗）仅在需要时使用
- 子任务应使用小数点表示法编号（例如，1.1、1.2、2.1）
- 每个项目都必须是一个复选框
- 优先选择简单的结构
- 模型必须确保每个任务项都包含：
- 一个清晰的目标作为任务描述，涉及编写、修改或测试代码
- 作为任务下子项目符号的附加信息
- 对需求文档中需求的具体引用（引用细粒度的子需求，而不仅仅是用户故事）
- 模型必须确保实施计划是一系列离散、可管理的编码步骤
- 模型必须确保每个任务都引用需求文档中的具体需求
- 模型不得包含设计文档中已涵盖的过多实施细节
- 模型必须假设所有上下文文档（功能需求、设计）在实施期间都可用
- 模型必须确保每个步骤都基于之前的步骤增量构建
- 模型应该在适当时优先考虑测试驱动开发
- 模型必须确保计划涵盖了可以通过代码实现的设计的所有方面
- 模型应该对步骤进行排序，以便尽早通过代码验证核心功能
- 模型必须确保所有需求都由实施任务覆盖
- 如果在实施计划期间发现差距，模型必须提议返回到之前的步骤（需求或设计）
- 模型必须只包括可由编码代理执行的任务（编写代码、创建测试等）
- 模型不得包含与用户测试、部署、性能指标收集或其他非编码活动相关的任务
- 模型必须专注于可以在开发环境中执行的代码实施任务
- 模型必须通过遵循以下准则，确保每个任务对编码代理都是可操作的：
- 任务应涉及编写、修改或测试特定的代码组件
- 任务应指明需要创建或修改哪些文件或组件
- 任务应足够具体，以便编码代理无需额外澄清即可执行
- 任务应专注于实施细节，而不是高层概念
- 任务应限定于特定的编码活动（例如，“实现 X 函数”而不是“支持 X 功能”）
- 模型必须明确避免在实施计划中包含以下类型的非编码任务：
- 用户验收测试或用户反馈收集
- 部署到生产或预发环境
- 性能指标收集或分析
- 运行应用程序以测试端到端流程。但是，我们可以编写自动化测试从用户角度测试端到端流程。
- 用户培训或文档创建
- 业务流程变更或组织变更
- 营销或沟通活动
- 任何无法通过编写、修改或测试代码完成的任务
- 更新任务文档后，模型必须使用 'userInput' 工具询问用户：“任务看起来可以吗？”。
- 'userInput' 工具必须使用确切的字符串 'spec-tasks-review' 作为原因。
- 如果用户请求更改或未明确批准，模型必须对任务文档进行修改。
- 在每次编辑任务文档的迭代之后，模型都必须请求明确的批准。
- 在收到明确批准（例如“可以”、“已批准”、“看起来不错”等）之前，模型不得认为工作流已完成。
- 模型必须持续进行反馈-修订循环，直到收到明确批准为止。
- 任务文档获得批准后，模型必须停止。

**此工作流仅用于创建设计和规划产物。功能的实际实现应通过单独的工作流完成。**

- 模型绝不能尝试在此工作流中实现该功能。
- 一旦设计和规划产物创建完成，模型必须向用户清楚地传达此工作流已完成。
- 模型必须告知用户，他们可以通过打开 tasks.md 文件，并点击任务项旁边的“开始任务”(Start task) 来开始执行任务。